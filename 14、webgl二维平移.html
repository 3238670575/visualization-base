<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl二维平移</title>
    <!-- <script type="text/javascript" src="dat.gui-master/build/dat.gui.min.js"></script> -->
</head>

<body>
    <canvas width="500" height="500"></canvas>
    <div id="uiContainer">
        <div id="ui">
            <div id="x"></div>
            <div id="y"></div>
        </div>
    </div>
</body>
<script type="module">
    import * as dat from './dat.gui-master/build/dat.gui.module.js'
    const gui = new dat.GUI();
    const gl = document.querySelector("canvas").getContext("webgl");
    const canvasWidth = gl.canvas.width;
    const canvasHeight = gl.canvas.height;
    let vertex;
    let fragment;
    let programInstance;
    let positionLocation;
    let resolutionLocation;
    let colorLocation;
    let translationLocation;
    let positionBuffer;
    const addShaderContext = async () => {
        await fetch('./14.vert')
            .then(response => response.text())
            .then(text => vertex = text)

        await fetch('./14.frag')
            .then(response => response.text())
            .then(text => fragment = text)
    }

    let xPosition,
        yPosition;

    //创建X,Y方向滑块
    const creatSlider = () => {
        const xSliderConfig = {
            value: 0,
            min: 0,
            max: canvasWidth,
            label: 'X'
        }
        const ySliderConfig = {
            value: 0,
            min: 0,
            max: canvasHeight,
            label: 'Y'
        }
        const xSlider = gui.add(xSliderConfig, 'value', xSliderConfig.min, xSliderConfig.max, xSliderConfig.step).name(xSliderConfig.label);
        const ySlider = gui.add(ySliderConfig, 'value', ySliderConfig.min, ySliderConfig.max, ySliderConfig.step).name(ySliderConfig.label);
        xSlider.onChange((value) => {
            console.log(value);
            xPosition = value;
            updatePosition(0, value);//更新X位置
        })
        ySlider.onChange((value) => {
            console.log(value);
            yPosition = value;
            updatePosition(1, value);//更新Y位置
        })
        const updateSliderValues = (xValue, yValue) => {
            xSliderConfig.value = xValue;
            ySliderConfig.value = yValue;
            gui.updateDisplay();
            console.log(xSliderConfig);
        }
    }

    //创建WebGLProgram
    const initProgram = () => {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertex);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragment);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        return program;
    };
    
    //绑定buffer数据
    const bindBufferData = () => {
        programInstance = initProgram();//创建webglprogram实例
        positionLocation = gl.getAttribLocation(programInstance, "a_position");
        resolutionLocation = gl.getUniformLocation(programInstance, "u_resolution");
        colorLocation = gl.getUniformLocation(programInstance, "u_color");
        translationLocation = gl.getUniformLocation(programInstance, "u_translation");
        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    }
   
    //更新位置
    const updatePosition = (index, value) => {
        translation[index] = value;
        drawScene(programInstance)
    }

    const translation = [0, 0];
    const width = 100;
    const height = 30;
    const color = [Math.random(), Math.random(), Math.random(), 1];

    //绘制场景
    const drawScene = (p) => {
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(p);
        gl.enableVertexAttribArray(positionLocation);

        // setRectangle(gl, translation[0], translation[1], width, height);
        // 设置位置属性的大小、类型、是否归一化等
        const size = 2;
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0;
        const offset = 0;
        gl.vertexAttribPointer(
            positionLocation,
            size,
            type,
            normalize,
            stride,
            offset
        );
        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
        gl.uniform4fv(colorLocation, color);;
        // 设置平移
        gl.uniform2fv(translationLocation, translation);
        const primitiveType = gl.TRIANGLES;
        // gl.drawArrays(primitiveType, 0, 6);
        gl.drawArrays(primitiveType, 0, 18);
    }

    //调整canvas大小
    const resizeCanvasToDisplaySize = (canvas, multiplier) => {
        multiplier = multiplier || 1;
        const width = canvas.clientWidth * multiplier | 0;
        const height = canvas.clientHeight * multiplier | 0;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            return true;
        }
        return false;
    }

    //设置矩形顶点数据
    const setRectangle = (gl, x, y, width, height) => {
        const x1 = x;
        const x2 = x + width;
        const y1 = y;
        const y2 = y + height;
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2,
            ]),
            gl.STATIC_DRAW);
    }
   
    //设置几何图形的顶点数据
    const setGeometry = () => {
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                // left column
                0, 0,
                30, 0,
                0, 150,
                0, 150,
                30, 0,
                30, 150,

                // top rung
                30, 0,
                100, 0,
                30, 30,
                30, 30,
                100, 0,
                100, 30,

                // middle rung
                30, 60,
                67, 60,
                30, 90,
                30, 90,
                67, 60,
                67, 90,
            ]),
            gl.STATIC_DRAW);
    }

    //主函数入口
    const main = async () => {
        await addShaderContext();//异步加载着色器文本内容
        creatSlider();//创建滑块
        bindBufferData();
        // setGeometry();
        drawScene(programInstance);//绘制场景
    }
    main();
</script>

</html>
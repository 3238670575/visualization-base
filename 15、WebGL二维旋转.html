<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl二维平移</title>
    <!-- <script type="text/javascript" src="dat.gui-master/build/dat.gui.min.js"></script> -->
    <style>
        canvas {
            border: 1px dashed salmon;
        }
    </style>
</head>

<body>
    <canvas width="500" height="500"></canvas>
</body>
<script type="module">
    import * as dat from './dat.gui-master/build/dat.gui.module.js'
    const gui = new dat.GUI();
    const gl = document.querySelector("canvas").getContext("webgl");
    const canvasWidth = gl.canvas.width;
    const canvasHeight = gl.canvas.height;
    let vertex;
    let fragment;
    let programInstance;
    let positionLocation;
    let resolutionLocation;
    let colorLocation;
    let translationLocation;
    let rotationLocation;
    let positionBuffer;
    const addShaderContext = async () => {
        await fetch('./vert//15.vert')
            .then(response => response.text())
            .then(text => vertex = text)

        await fetch('./frag/15.frag')
            .then(response => response.text())
            .then(text => fragment = text)
    }

    //创建X,Y方向滑块
    const creatSlider = () => {
        const xSliderConfig = {
            value: 0,
            min: 0,
            max: canvasWidth,
            label: 'X'
        }
        const ySliderConfig = {
            value: 0,
            min: 0,
            max: canvasHeight,
            label: 'Y'
        }
        const angelSliderConfig = {
            value: 0,
            min: 0,
            max: 360,
            label: 'Angle',
        }
        const xSlider = gui.add(xSliderConfig, 'value', xSliderConfig.min, xSliderConfig.max, xSliderConfig.step).name(xSliderConfig.label);
        const ySlider = gui.add(ySliderConfig, 'value', ySliderConfig.min, ySliderConfig.max, ySliderConfig.step).name(ySliderConfig.label);
        const angelSlider = gui.add(angelSliderConfig, 'value', angelSliderConfig.min, angelSliderConfig.max, angelSliderConfig.step).name(angelSliderConfig.label);
        xSlider.onChange((value) => {
            updatePosition(0, value);//更新X位置
        })
        ySlider.onChange((value) => {
            updatePosition(1, value);//更新Y位置
        })
        angelSlider.onChange((value) => {
            console.log(value);
            updateRotation(value);
        })
        const updateSliderValues = (xValue, yValue) => {
            xSliderConfig.value = xValue;
            ySliderConfig.value = yValue;
            gui.updateDisplay();
        }
    }

    //创建WebGLProgram
    const initProgram = () => {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertex);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragment);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        return program;
    };

    //绑定buffer数据
    const bindBufferData = () => {
        programInstance = initProgram();//创建webglprogram实例
        positionLocation = gl.getAttribLocation(programInstance, "a_position");
        resolutionLocation = gl.getUniformLocation(programInstance, "u_resolution");
        colorLocation = gl.getUniformLocation(programInstance, "u_color");
        translationLocation = gl.getUniformLocation(programInstance, "u_translation");
        rotationLocation = gl.getUniformLocation(programInstance, 'u_rotation');

        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    }

    //更新位置
    const updatePosition = (index, value) => {
        translation[index] = value;
        drawScene(programInstance)
    }
    //更新旋转角度
    const updateRotation = (value) => {
        rotation[0] = Math.sin((360 - value) * Math.PI / 180);//u_x = sin A
        rotation[1] = Math.cos((360 - value) * Math.PI / 180);//u_y = cos A
        drawScene(programInstance)
    }
    const translation = [0, 0];
    const rotation = [0, 1];//初始旋转角度正、余弦值，sin -A =u_rotation.x = 0，cos -A =u_rotation.y = 1
    const width = 100;
    const height = 30;
    const color = [Math.random(), Math.random(), Math.random(), 1];

    //绘制场景
    const drawScene = (p) => {
        resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(p);
        gl.enableVertexAttribArray(positionLocation);
        // 设置位置属性的大小、类型、是否归一化等
        const size = 2;
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0;
        const offset = 0;
        gl.vertexAttribPointer(
            positionLocation,
            size,
            type,
            normalize,
            stride,
            offset
        );


        gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
        // gl.uniform4fv(colorLocation, color);
        // 设置平移
        gl.uniform2fv(translationLocation, translation);
        gl.uniform2fv(rotationLocation, rotation);
        // 绘制三角形
        const primitiveType = gl.TRIANGLES;
        gl.drawArrays(primitiveType, 0, 18);
    }

    //调整canvas大小
    const resizeCanvasToDisplaySize = (canvas, multiplier) => {
        multiplier = multiplier || 1;
        const width = canvas.clientWidth * multiplier | 0;
        const height = canvas.clientHeight * multiplier | 0;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            return true;
        }
        return false;
    }


    //设置几何图形的顶点数据
    const setGeometry = () => {
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                // left column
                0, 0,
                30, 0,
                0, 150,
                0, 150,
                30, 0,
                30, 150,

                // top rung
                30, 0,
                100, 0,
                30, 30,
                30, 30,
                100, 0,
                100, 30,

                // middle rung
                30, 60,
                67, 60,
                30, 90,
                30, 90,
                67, 60,
                67, 90,
            ]),
            gl.STATIC_DRAW);
    }

    //主函数入口
    const main = async () => {
        await addShaderContext();//异步加载着色器文本内容
        creatSlider();//创建滑块
        bindBufferData();
        setGeometry();
        drawScene(programInstance);//绘制场景
    }
    main();
</script>

</html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>webgl二维平移</title>
    <style>
        canvas {
            border: 1px dashed salmon;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>

<body>
    <canvas width="500" height="100"></canvas>
</body>
<script type="module">
    import * as dat from './dat.gui-master/build/dat.gui.module.js'
    const gui = new dat.GUI();
    const gl = document.querySelector("canvas").getContext("webgl");
    const canvasWidth = gl.canvas.width;
    const canvasHeight = gl.canvas.height;
    let vertex;
    let fragment;
    let programInstance;
    let positionLocation;
    let matrixLocation;
    let positionBuffer;
    const addShaderContext = async () => {
        await fetch('./vert/16.vert')
            .then(response => response.text())
            .then(text => vertex = text)

        await fetch('./frag/16.frag')
            .then(response => response.text())
            .then(text => fragment = text)
    }

    //创建X,Y方向滑块
    const creatSlider = () => {
        const canvasWidth = gl.canvas.width;
        const canvasHeight = gl.canvas.height;
        const xSliderConfig = {
            value: 60,
            min: 0,
            max: canvasWidth,
            label: 'X'
        }
        const ySliderConfig = {
            value: 40,
            min: 0,
            max: canvasHeight,
            label: 'Y'
        }
        const angelSliderConfig = {
            value: 0,
            min: 0,
            max: 360,
            label: 'Angle',
        }
        const xscaleSliderConfig = {
            value: 0.85,
            min: -5,
            max: 5,
            label: 'scaleX',
        }
        const yscaleSliderConfig = {
            value: 0.85,
            min: -5,
            max: 5,
            label: 'scaleY',
        }
        const xSlider = gui.add(xSliderConfig, 'value', xSliderConfig.min, xSliderConfig.max).name(xSliderConfig.label);
        const ySlider = gui.add(ySliderConfig, 'value', ySliderConfig.min, ySliderConfig.max).name(ySliderConfig.label);
        const angelSlider = gui.add(angelSliderConfig, 'value', angelSliderConfig.min, angelSliderConfig.max).name(angelSliderConfig.label);
        const xScaleSlider = gui.add(xscaleSliderConfig, 'value', xscaleSliderConfig.min, xscaleSliderConfig.max).name(xscaleSliderConfig.label);
        const yScaleSlider = gui.add(yscaleSliderConfig, 'value', yscaleSliderConfig.min, yscaleSliderConfig.max).name(yscaleSliderConfig.label);
        xSlider.onChange((value) => {
            updatePosition(0, value);//更新X位置
        })
        ySlider.onChange((value) => {
            updatePosition(1, value);//更新Y位置
        })
        angelSlider.onChange((value) => {
            console.log(value);
            updateRotation(value);
        })
        xScaleSlider.onChange((value) => {
            updateScale(0, value)
        })
        yScaleSlider.onChange((value) => {
            updateScale(1, value)
        })
    }

    //创建WebGLProgram
    const initProgram = () => {
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertex);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragment);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);
        return program;
    };

    //绑定buffer数据
    const bindBufferData = () => {
        programInstance = initProgram();//创建webglprogram实例
        positionLocation = gl.getAttribLocation(programInstance, "a_position");
        matrixLocation = gl.getUniformLocation(programInstance, "u_matrix");

        positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    }

    //更新位置
    const updatePosition = (index, value) => {
        translation[index] = value;
        drawScene(programInstance)
    }
    //更新旋转角度
    const updateRotation = (value) => {
        angleInRadians = (360 - value) * Math.PI / 180
        drawScene(programInstance)
    }
    const updateScale = (index, value) => {
        scale[index] = value;
        drawScene(programInstance, gl)
    }
    const translation = [60, 40];
    let angleInRadians = 0;
    const scale = [0.85, 0.85]

    //绘制场景
    const drawScene = (p) => {
        // resizeCanvasToDisplaySize(gl.canvas);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(p);
        gl.enableVertexAttribArray(positionLocation);
        // 设置位置属性的大小、类型、是否归一化等
        const size = 2;
        const type = gl.FLOAT;
        const normalize = false;
        const stride = 0;
        const offset = 0;
        gl.vertexAttribPointer(
            positionLocation,
            size,
            type,
            normalize,
            stride,
            offset
        );


        // let matrix = m3.identity();
        let matrix = m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight);
        // let matrix = m3.projection(gl.canvas.width, gl.canvas.height);

        // matrix = m3.multiply(matrix, projectionMatrix);
        // const moveOriginMatrix = m3.translation(-30, -150);//指定旋转中心

        matrix = m3.translate(matrix, translation[0], translation[1]);
        matrix = m3.rotate(matrix, angleInRadians);
        matrix = m3.scale(matrix, scale[0], scale[1]);
        // matrix = m3.multiply(matrix, moveOriginMatrix);


        gl.uniformMatrix3fv(matrixLocation, false, matrix);
        // 绘制三角形
        const primitiveType = gl.TRIANGLES;
        gl.drawArrays(primitiveType, 0, 18);
        window.addEventListener('resize',()=>{
            drawScene(programInstance)
        },false)
    }

    //调整canvas大小
    const resizeCanvasToDisplaySize = (canvas, multiplier) => {
        multiplier = multiplier || 1;
        const width = canvas.clientWidth * multiplier | 0;
        const height = canvas.clientHeight * multiplier | 0;
        if (canvas.width !== width || canvas.height !== height) {
            canvas.width = width;
            canvas.height = height;
            return true;
        }
        return false;
    }


    //设置几何图形的顶点数据
    const setGeometry = () => {
        gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array([
                // left column
                0, 0,
                30, 0,
                0, 150,
                0, 150,
                30, 0,
                30, 150,

                // top rung
                30, 0,
                100, 0,
                30, 30,
                30, 30,
                100, 0,
                100, 30,

                // middle rung
                30, 60,
                67, 60,
                30, 90,
                30, 90,
                67, 60,
                67, 90,
            ]),
            gl.STATIC_DRAW);
    }
    const m3 = {
        identity: function () {
            return [
                1, 0, 0,
                0, 1, 0,
                0, 0, 1,
            ];
        },

        translation: function (tx, ty) {
            return [
                1, 0, 0,
                0, 1, 0,
                tx, ty, 1,
            ];
        },

        rotation: function (angleInRadians) {
            const c = Math.cos(angleInRadians);
            const s = Math.sin(angleInRadians);
            return [
                c, -s, 0,
                s, c, 0,
                0, 0, 1,
            ];
        },

        scaling: function (sx, sy) {
            return [
                sx, 0, 0,
                0, sy, 0,
                0, 0, 1,
            ];
        },

        multiply: function (a, b) {
            const a00 = a[0 * 3 + 0];
            const a01 = a[0 * 3 + 1];
            const a02 = a[0 * 3 + 2];
            const a10 = a[1 * 3 + 0];
            const a11 = a[1 * 3 + 1];
            const a12 = a[1 * 3 + 2];
            const a20 = a[2 * 3 + 0];
            const a21 = a[2 * 3 + 1];
            const a22 = a[2 * 3 + 2];
            const b00 = b[0 * 3 + 0];
            const b01 = b[0 * 3 + 1];
            const b02 = b[0 * 3 + 2];
            const b10 = b[1 * 3 + 0];
            const b11 = b[1 * 3 + 1];
            const b12 = b[1 * 3 + 2];
            const b20 = b[2 * 3 + 0];
            const b21 = b[2 * 3 + 1];
            const b22 = b[2 * 3 + 2];
            return [
                b00 * a00 + b01 * a10 + b02 * a20,
                b00 * a01 + b01 * a11 + b02 * a21,
                b00 * a02 + b01 * a12 + b02 * a22,
                b10 * a00 + b11 * a10 + b12 * a20,
                b10 * a01 + b11 * a11 + b12 * a21,
                b10 * a02 + b11 * a12 + b12 * a22,
                b20 * a00 + b21 * a10 + b22 * a20,
                b20 * a01 + b21 * a11 + b22 * a21,
                b20 * a02 + b21 * a12 + b22 * a22,
            ];
        },
        projection: function (width, height) {
            return [
                2 / width, 0, 0,
                0, -2 / height, 0,
                -1, 1, 1
            ]
        },
        translate: function (m, tx, ty) {
            return m3.multiply(m, m3.translation(tx, ty));
        },

        rotate: function (m, angleInRadians) {
            return m3.multiply(m, m3.rotation(angleInRadians));
        },

        scale: function (m, sx, sy) {
            return m3.multiply(m, m3.scaling(sx, sy));
        },
    };
    //主函数入口
    const main = async () => {
        await addShaderContext();//异步加载着色器文本内容
        creatSlider();//创建滑块
        bindBufferData();
        setGeometry();
        drawScene(programInstance);//绘制场景
    }
    main();
</script>

</html>